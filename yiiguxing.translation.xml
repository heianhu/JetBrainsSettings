<application>
  <component name="AppStorage">
    <histories>
      <item value="You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API." />
      <item value="Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad." />
      <item value="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad." />
      <item value="Do not return anything, modify nums1 in-place instead." />
      <item value="You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2." />
      <item value="Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array." />
      <item value="The number of elements initialized in nums1 and nums2 are m and n respectively." />
      <item value="maximum recursion depth exceeded" />
      <item value="a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1" />
      <item value="For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1." />
      <item value="Given an array where elements are sorted in ascending order, convert it to a height balanced BST." />
      <item value="Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level)." />
      <item value="Session" />
      <item value="Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center)." />
      <item value="The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees." />
      <item value="Given a binary tree, determine if it is a valid binary search tree (BST)." />
      <item value="left" />
      <item value="Can you solve it using O(1) (i.e. constant) memory?" />
      <item value="There is a cycle in the linked list, where tail connects to the second node." />
      <item value="we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to" />
      <item value="To represent a cycle in the given linked list" />
      <item value="To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list." />
      <item value="Given a linked list, determine if it has a cycle in it." />
      <item value="Given a singly linked list, determine if it is a palindrome." />
      <item value="Could you do it in O(n) time and O(1) space?" />
      <item value="Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists." />
      <item value="string inserted between values, default a space." />
      <item value="A linked list can be reversed either iteratively or recursively" />
      <item value="A linked list can be reversed either iteratively or recursively. Could you implement both?" />
      <item value="Given n will always be valid." />
      <item value="Given a linked list, remove the n-th node from the end of list and return its head." />
      <item value="Could you do this in one pass?" />
      <item value="The linked list will have at least two elements." />
      <item value="Solution" />
      <item value="Write a function to delete a node (except the tail) in a singly linked list, given only access to that node." />
      <item value="The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function." />
      <item value="You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function." />
      <item value="Given linked list -- head = [4,5,1,9], which looks like following:" />
      <item value="Got a packet bigger than 'max_allowed_packet' bytes&quot;" />
      <item value="prefix" />
      <item value="common" />
      <item value="amongst" />
      <item value="Write a function to find the longest common prefix string amongst an array of strings." />
      <item value="All given inputs are in lowercase letters a-z." />
      <item value="Explanation: For n = 3 the term was &quot;21&quot; in which we have two groups &quot;2&quot; and &quot;1&quot;, &quot;2&quot; can be read as &quot;12&quot; which means frequency = 1 and value = 2, the same way &quot;1&quot; is read as &quot;11&quot;, so the answer is the concatenation of &quot;12&quot; and &quot;11&quot; which is &quot;1211&quot;." />
      <item value="Explanation: For n = 3 the term was &quot;21&quot; in which we have two groups &quot;2&quot; and &quot;1&quot;, &quot;2&quot; can be read as &quot;12&quot; which means fre" />
      <item value="Note: Each term of the sequence of integers will be represented as a string." />
      <item value="Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit." />
      <item value="The count-and-say sequence is the sequence of integers with the first five terms as following:" />
      <item value="e: Each term of the sequence of integers will be represented as a string." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="287" />
        <entry key="ENGLISH" value="282" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="5" />
        <entry key="JAPANESE" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="21f11c9eab80f4f2" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>